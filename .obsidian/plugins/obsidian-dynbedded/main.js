/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Dynbedded
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/DynbeddedSettingTab.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  debugLogging: false
};
var DynbeddedSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: this.plugin.pluginName });
    containerEl.createEl("h2", { text: this.plugin.pluginDescription });
    containerEl.createEl("b", { text: " Version: " + this.plugin.pluginVersion });
    containerEl.createEl("br", { text: "" });
    containerEl.createEl("br", { text: "" });
    containerEl.createEl("a", { text: "Created by " + this.plugin.pluginAuthor, href: this.plugin.pluginAuthorUrl });
    containerEl.createEl("br", { text: "" });
    containerEl.createEl("br", { text: "" });
    containerEl.createEl("a", { text: "Plugin Documentation", href: this.plugin.pluginDocumentationUrl });
    containerEl.createEl("br", { text: "" });
    containerEl.createEl("br", { text: "" });
    const coffeeDiv = containerEl.createDiv("coffee");
    coffeeDiv.addClass("ex-coffee-div");
    const coffeeLink = coffeeDiv.createEl("a", {
      href: "https://ko-fi.com/mmomm"
    });
    const coffeeImg = coffeeLink.createEl("img", {
      attr: {
        src: "https://cdn.ko-fi.com/cdn/kofi3.png?v=3"
      }
    });
    coffeeImg.height = 45;
    containerEl.createEl("h3", { text: "Developer Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Debug Logging").setDesc("If this is enabled, more things are printed to the console.").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugLogging).onChange(async (value) => {
      this.plugin.log("Debug Logging", value);
      this.plugin.settings.debugLogging = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/DynbeddedProcessor.ts
var import_obsidian2 = require("obsidian");
var DynbeddedProcessor = class {
  constructor(app2, plugin) {
    this.plugin = plugin;
    this.app = app2;
  }
  async render(source, el, ctx) {
    const fileNameMatchPattern = /\[\[([^\]]{2}.*)\]\]/u;
    const fileNameMatch = fileNameMatchPattern.exec(source);
    this.plugin.log("FileNameMatch", fileNameMatch);
    if (!fileNameMatch) {
      Dynbedded.displayError(el, "Bad file link: " + source);
      return;
    }
    let fileName = fileNameMatch[1];
    const dynamicDateMatchPattern = /{{(.*)}}/;
    const dynamicDateMatch = dynamicDateMatchPattern.exec(fileName);
    this.plugin.log("DynamicDateMatch", dynamicDateMatch);
    if (dynamicDateMatch !== null) {
      const { dynamicDateFormat, dynamicDate } = this.getDynamicDate(dynamicDateMatch);
      if (!window.moment(window.moment.now(), dynamicDateFormat, true).isValid || dynamicDate === null) {
        Dynbedded.displayError(el, "Not a valid Moment.js Time format: " + dynamicDateFormat);
        return;
      }
      fileName = fileName.replace(dynamicDateMatchPattern, dynamicDate);
      this.plugin.log("DynamicFileName", fileName);
    }
    let header = "";
    if (fileName.contains("#")) {
      const __ret = this.splitFileName(fileName);
      header = __ret.header;
      fileName = __ret.fileName;
    }
    const matchingFile = this.app.metadataCache.getFirstLinkpathDest(fileName, "");
    this.plugin.log("MatchingFile", matchingFile);
    if (!matchingFile) {
      Dynbedded.displayError(el, "File link not found: [[" + fileName + "]]");
      return;
    }
    if (matchingFile.extension !== "md") {
      Dynbedded.displayError(el, "Bad file extension found, expected markdown: " + matchingFile);
      return;
    }
    let fileContents = "";
    if (header != "") {
      const headings = this.app.metadataCache.getFileCache(matchingFile).headings;
      if (headings === null || headings === void 0) {
        const errorMessage = 'Header "' + header + '" not found in [[' + fileName + "]]";
        Dynbedded.displayError(el, errorMessage);
        return;
      }
      this.plugin.log("Headings", headings);
      let position;
      for (let i = 0; i < headings.length; i++) {
        const heading = headings[i];
        this.plugin.log("Heading", heading);
        if (heading.heading == header) {
          if (i == headings.length - 1) {
            position = [heading.position.start.line, -1];
          } else {
            position = [heading.position.start.line, headings[i + 1].position.start.line];
          }
        }
      }
      if (position) {
        fileContents = await this.getHeaderSectionContent(matchingFile, position, fileContents);
      }
    } else {
      fileContents = await this.app.vault.cachedRead(matchingFile);
    }
    if (fileContents == "") {
      const errorMessage = 'Header "' + header + '" not found in [[' + fileName + "]]";
      Dynbedded.displayError(el, errorMessage);
      return;
    }
    this.plugin.log("File", fileContents);
    const container = el.createDiv({ cls: [Dynbedded.containerClass] });
    await import_obsidian2.MarkdownRenderer.renderMarkdown(fileContents, container, ctx.sourcePath, this.plugin);
  }
  getDynamicDate(dynamicDateMatch) {
    let dynamicDateFormat = dynamicDateMatch[1];
    let duration = window.moment.duration(0);
    this.plugin.log("DynamicDateFormat", dynamicDateFormat.includes("|"));
    if (dynamicDateFormat.includes("|")) {
      const offset = dynamicDateFormat.split("|")[1];
      this.plugin.log("Offset", offset);
      dynamicDateFormat = dynamicDateFormat.split("|")[0];
      this.plugin.log("dynamicDateMatch", dynamicDateFormat);
      if (/^-?\d+$/.test(offset)) {
        this.plugin.log("Number");
        duration = window.moment.duration(Number(offset), "days");
      } else {
        this.plugin.log("String");
        duration = window.moment.duration(offset);
      }
      this.plugin.log("Duration", duration);
    }
    const dynamicDate = window.moment().add(duration).format(dynamicDateFormat);
    this.plugin.log("DynamicDate", dynamicDate);
    return { dynamicDateFormat, dynamicDate };
  }
  async getHeaderSectionContent(matchingFile, position, fileContents) {
    let text = await this.app.vault.cachedRead(matchingFile);
    if (!text.endsWith("\n")) {
      text = text + "\n";
    }
    this.plugin.log("Position", position);
    this.plugin.log("Text", text);
    fileContents = text.split("\n").slice(position[0] + 1, position[1]).join("\n");
    this.plugin.log("Split", fileContents);
    return fileContents;
  }
  splitFileName(fileName) {
    const header = fileName.split("#")[1];
    fileName = fileName.split("#")[0];
    this.plugin.log("Header", header);
    return { header, fileName };
  }
};

// src/main.ts
var _Dynbedded = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.pluginName = this.manifest.name;
    this.pluginDescription = this.manifest.description;
    this.pluginVersion = this.manifest.version;
    this.pluginAuthor = this.manifest.author;
    this.pluginAuthorUrl = this.manifest.authorUrl;
    this.pluginDocumentationUrl = "https://github.com/MMoMM-org/obsidian-dynbedded";
    this.dynbeddedProcessor = new DynbeddedProcessor(app, this);
  }
  async onload() {
    await this.loadSettings();
    this.log("Loading Plugin");
    this.addSettingTab(new DynbeddedSettingTab(this.app, this));
    this.registerMarkdownCodeBlockProcessor(_Dynbedded.codeBlockKeyword, async (source, el, ctx) => {
      this.dynbeddedProcessor.render(source, el, ctx);
    });
  }
  onunload() {
    this.log("Unloading Plugin");
  }
  log(...args) {
    if (this.settings.debugLogging) {
      console.log(this.pluginName + "-Debug:", ...args);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.log("Settings loaded", this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.log("Settings saved", this.settings);
  }
};
var Dynbedded = _Dynbedded;
Dynbedded.codeBlockKeyword = "dynbedded";
Dynbedded.containerClass = "dynbedded";
Dynbedded.errorClass = "dynbedded-error";
Dynbedded.displayError = (parent, text) => {
  console.log("Dynbedded-Error: ", text);
  parent.createEl("pre", { text: "Dynbedded: Error: " + text, cls: [_Dynbedded.containerClass, _Dynbedded.errorClass] });
};
